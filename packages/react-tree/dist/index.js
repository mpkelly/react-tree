/*! For license information please see index.js.LICENSE.txt */
!function(e,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n(require("react"));else if("function"==typeof define&&define.amd)define(["react"],n);else{var t="object"==typeof exports?n(require("react")):n(e.React);for(var r in t)("object"==typeof exports?exports:e)[r]=t[r]}}(window,(function(__WEBPACK_EXTERNAL_MODULE_react__){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="./dist",t(t.s="./src/Index.ts")}({"./src/CollapseToggle.tsx":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.CollapseToggle = void 0;\n\nconst react_1 = __importDefault(__webpack_require__(/*! react */ "react"));\n\nconst Tree_1 = __webpack_require__(/*! ./Tree */ "./src/Tree.tsx");\n/**\n * Wraps any valid `ReactNode` and provides a click handler for\n * toggling between expanded/collapsed state. You should wrap your angle\n * bracket icon or whatever with this.\n */\n\n\nexports.CollapseToggle = props => {\n  const {\n    children,\n    node\n  } = props;\n  const collapsed = !node.expanded;\n  const {\n    handleToggleCollapse\n  } = Tree_1.useTreeContext();\n\n  if (!handleToggleCollapse) {\n    throw Error("It looks like you\'re trying to use CollapseToggle outside of the <Tree/> scope");\n  }\n\n  return react_1.default.createElement("div", {\n    "data-rt-collapse-toggle": true,\n    "data-rt-collapsed": collapsed,\n    onClick: () => handleToggleCollapse(node)\n  }, children);\n};\n\n//# sourceURL=webpack:///./src/CollapseToggle.tsx?')},"./src/Index.ts":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\n__exportStar(__webpack_require__(/*! ./CollapseToggle */ "./src/CollapseToggle.tsx"), exports);\n\n__exportStar(__webpack_require__(/*! ./Node */ "./src/Node.ts"), exports);\n\n__exportStar(__webpack_require__(/*! ./Tree */ "./src/Tree.tsx"), exports);\n\n__exportStar(__webpack_require__(/*! ./TreeElement */ "./src/TreeElement.tsx"), exports);\n\n__exportStar(__webpack_require__(/*! ./Schema */ "./src/Schema.ts"), exports);\n\n//# sourceURL=webpack:///./src/Index.ts?')},"./src/Node.ts":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.findTreeNodeById = exports.toTreeNodes = exports.toTreeNode = exports.toFlatNodes = exports.toFlatNode = exports.sortTree = exports.createAlphaNumericSort = void 0;\n/**\n * Creates a simple sorting function that performs an alpha-numeric sort\n * using `String.localeCompare`.\n *\n * @param property the property on the node you wish to use for sorting.\n * This property is typically called `name` or `title` etc.\n */\n\nexports.createAlphaNumericSort = property => {\n  return (a, b) => {\n    return String(a[property]).localeCompare(String(b[property]));\n  };\n};\n\nexports.sortTree = (tree, sortFunction) => {\n  tree.sort(sortFunction);\n  tree.forEach(node => {\n    exports.sortTree(node.children, sortFunction);\n  });\n};\n\nexports.toFlatNode = (node, parentId) => {\n  const {\n    children\n  } = node,\n        rest = __rest(node, ["children"]);\n\n  return Object.assign(Object.assign({}, rest), {\n    parentId\n  });\n};\n/**\n *\n * @param nodes The `TreeNodes` to flatten into `FlatNodes`.\n * @param parentId The parentId of the subtree or undefined if the `nodes`\n * array contains root elements.\n */\n\n\nexports.toFlatNodes = (nodes, parentId) => {\n  let items = [];\n  nodes.forEach(node => {\n    items.push(exports.toFlatNode(node, parentId));\n    items = items.concat(exports.toFlatNodes(node.children, node.id));\n  });\n  return items;\n};\n\nexports.toTreeNode = node => {\n  return Object.assign(Object.assign({}, node), {\n    children: []\n  });\n};\n/**\n * Convert an array of `FlatNode`s into a tree.\n *\n * @param nodes the `FlatNode`s to convert into a tree.\n */\n\n\nexports.toTreeNodes = nodes => {\n  const table = Object.create(null);\n  nodes.forEach(node => table[node.id] = exports.toTreeNode(node));\n  const tree = [];\n  nodes.forEach(node => {\n    if (node.parentId !== undefined) {\n      table[node.parentId].children.push(table[node.id]);\n    } else {\n      tree.push(table[node.id]);\n    }\n  });\n  return tree;\n};\n/**\n * Find a `TreeNode` somewhere on a tree. The parent is also returned\n * if it is exists i.e. non-root nodes.\n *\n * @param id the ID to search for\n * @param nodes the nodes to search\n */\n\n\nexports.findTreeNodeById = (id, nodes, parent = null) => {\n  for (let node of nodes) {\n    if (node.id === id) {\n      return {\n        node,\n        parent\n      };\n    } else {\n      const result = exports.findTreeNodeById(id, node.children, node);\n\n      if (result) {\n        return result;\n      }\n    }\n  }\n\n  return null;\n};\n\n//# sourceURL=webpack:///./src/Node.ts?')},"./src/Schema.ts":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.isDropAllowed = void 0;\n\nexports.isDropAllowed = (dragNode, dropNode, schema) => {\n  if (!schema) return true;\n  const accepts = schema.rules ? schema.rules[dropNode.type] : undefined;\n\n  if (accepts && accepts.length === 0) {\n    return false;\n  } else if (accepts && !accepts.includes(dragNode.type)) {\n    return false;\n  } else if (schema.isDropAllowed) {\n    return schema.isDropAllowed(dragNode, dropNode);\n  }\n\n  return true;\n};\n\n//# sourceURL=webpack:///./src/Schema.ts?')},"./src/Tree.tsx":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, "default", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o["default"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Tree = exports.useTreeContext = exports.TreeContext = void 0;\n\nconst react_1 = __importStar(__webpack_require__(/*! react */ "react"));\n\nconst Node_1 = __webpack_require__(/*! ./Node */ "./src/Node.ts");\n\nconst TreeElement_1 = __webpack_require__(/*! ./TreeElement */ "./src/TreeElement.tsx");\n\nconst Schema_1 = __webpack_require__(/*! ./Schema */ "./src/Schema.ts");\n\nexports.TreeContext = react_1.createContext(undefined);\n\nexports.useTreeContext = () => {\n  return react_1.useContext(exports.TreeContext);\n};\n/**\n * See docs on `TreeProps`.\n */\n\n\nexports.Tree = props => {\n  const {\n    nodes,\n    renderElement,\n    onChange,\n    sortFunction,\n    readOnly,\n    schema\n  } = props;\n  const [dragId, setDragId] = react_1.useState();\n  const [overId, setOverId] = react_1.useState();\n  const treeNodes = Node_1.toTreeNodes(nodes);\n\n  if (sortFunction) {\n    Node_1.sortTree(treeNodes, sortFunction);\n  }\n\n  const handleDrop = (dropped, target) => {\n    if (target !== undefined) {\n      const node = nodes.find(node => String(node.id) === String(dropped));\n\n      if (node && String(node.parentId) !== String(target)) {\n        onChange && onChange(node, "parentId", target);\n      }\n    }\n\n    setOverId(undefined);\n    setDragId(undefined);\n  };\n\n  const handleToggleCollapse = node => {\n    onChange && onChange(node, "expanded", !node.expanded);\n  };\n\n  const handleOver = react_1.useCallback(overId => {\n    if (overId === undefined) {\n      setOverId(undefined);\n      return;\n    } // Don\'t allow drop on self\n\n\n    if (dragId === overId) {\n      return;\n    }\n\n    const dragNode = nodes.find(node => node.id === dragId);\n\n    if (dragNode) {\n      if (dragNode.dragDisabled) {\n        return;\n      } // Don\'t allow dropping into existing parent\n\n\n      if (dragNode.parentId === overId) {\n        return;\n      }\n\n      const overNode = nodes.find(node => node.id === overId);\n\n      if (overNode) {\n        const search = Node_1.findTreeNodeById(dragId, treeNodes);\n\n        if (search && search.node) {\n          const children = Node_1.toFlatNodes(search.node.children); // Don\'t allow dropping into a child node\n\n          if (children.find(child => child.id == overId)) {\n            return;\n          }\n        } // Validate against schema, if set\n\n\n        if (Schema_1.isDropAllowed(dragNode, overNode, schema)) {\n          setOverId(overId);\n        }\n      }\n    }\n  }, [dragId]);\n  const renderTree = react_1.useCallback((nodes, depth = 0) => {\n    const result = [];\n    nodes.forEach(node => {\n      const nodeItem = renderElement(node, depth);\n      let children = [];\n\n      if (node.expanded === undefined || node.expanded) {\n        children = renderTree(node.children, depth + 1);\n      }\n\n      let props = {};\n\n      if (node.id === overId && overId !== node.parentId) {\n        props["data-rt-drop-valid"] = true;\n      }\n\n      result.push(react_1.default.createElement("div", Object.assign({\n        "data-rt-element-wrapper": node.id\n      }, props), react_1.default.createElement(TreeElement_1.TreeElement, {\n        node: node,\n        depth: depth\n      }, nodeItem), children));\n    });\n    return result;\n  }, [overId]);\n  const tree = renderTree(treeNodes);\n  const value = {\n    overId,\n    handleDrag: setDragId,\n    handleOver,\n    handleDrop,\n    handleToggleCollapse,\n    readOnly: Boolean(readOnly)\n  };\n  return react_1.default.createElement(exports.TreeContext.Provider, {\n    value: value\n  }, react_1.default.createElement("div", {\n    "data-rt-tree": true\n  }, tree));\n};\n\n//# sourceURL=webpack:///./src/Tree.tsx?')},"./src/TreeElement.tsx":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    "default": mod\n  };\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.TreeElement = void 0;\n\nconst react_1 = __importDefault(__webpack_require__(/*! react */ "react"));\n\nconst TreeElementState_1 = __webpack_require__(/*! ./TreeElementState */ "./src/TreeElementState.ts");\n\nexports.TreeElement = props => {\n  const {\n    node,\n    children,\n    dragDisabled\n  } = props;\n  const {\n    id\n  } = node;\n  const elementProps = TreeElementState_1.useTreeElementState(props);\n  const draggable = !(node.dragDisabled || dragDisabled);\n  return react_1.default.createElement("div", Object.assign({\n    key: id,\n    draggable: draggable\n  }, elementProps), children);\n};\n\n//# sourceURL=webpack:///./src/TreeElement.tsx?')},"./src/TreeElementState.ts":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.useTreeElementState = void 0;\n\nconst react_1 = __webpack_require__(/*! react */ "react");\n\nconst Tree_1 = __webpack_require__(/*! ./Tree */ "./src/Tree.tsx");\n\nexports.useTreeElementState = props => {\n  const {\n    node,\n    depth,\n    dragDisabled\n  } = props;\n  const {\n    overId,\n    handleDrag,\n    handleOver,\n    handleDrop,\n    readOnly\n  } = Tree_1.useTreeContext();\n\n  if (readOnly) {\n    return {};\n  }\n\n  let onDragStart = undefined;\n\n  if (!dragDisabled && !node.dragDisabled) {\n    onDragStart = event => {\n      event.dataTransfer.setData("text/rt-id", String(node.id));\n      event.dataTransfer.dropEffect = "move";\n      handleDrag(node.id);\n    };\n  }\n\n  const onDragOver = event => {\n    handleOver(node.id);\n    event.preventDefault();\n    event.dataTransfer.dropEffect = "move";\n  };\n\n  const onDragLeave = () => {\n    handleOver(undefined);\n  };\n\n  const onDrop = react_1.useCallback(event => {\n    event.preventDefault();\n\n    if (overId !== undefined && overId == node.id) {\n      const id = event.dataTransfer.getData("text/rt-id");\n      handleDrop(id, node.id);\n    }\n  }, [overId]);\n  const elementProps = {\n    "data-rt-element": node.id,\n    "data-rt-type": node.type,\n    "data-rt-depth": depth,\n    draggable: !dragDisabled,\n    onDragStart,\n    onDragOver,\n    onDragLeave,\n    onDrop\n  };\n  return elementProps;\n};\n\n//# sourceURL=webpack:///./src/TreeElementState.ts?')},react:function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n\n//# sourceURL=webpack:///external_%7B%22commonjs%22:%22react%22,%22commonjs2%22:%22react%22,%22amd%22:%22react%22,%22root%22:%22React%22,%22umd%22:%22react%22%7D?")}})}));